---
title: "Simulating Clusters with Both Continuous and Categorical Variables"
output: rmarkdown::github_document
date: '2022-08-11'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.retina = 2)
```


## Continuous Variables

Convex clusters of continuous variables can be generated simply as multivariate Gaussians.

```{r}

# load packages

library(mvtnorm) # for function rmvnorm
library(clusterGeneration) # for function rcorrmatrix

```

Generate two clusters. 

To generate a Gaussian cluster, we need to specify the cluster mean vector and the cluster covariance matrix. 

The mean vectors are generated by random sampling from a continuous uniform distribution. The distance between the cluster means is a function of the interval length of the uniform distribution: a shorter interval leads to clusters that are closer to each other. 

The `rcorrmatrix` function from the package `clusterGeneration` generates random correlation matrices and is used to generate the covariance matrices for the clusters.

The randomly generated mean vector and covariance matrix are then inputs to the `rmvnorm` function from the `mvtnorm` package which outputs the desired number of cluster datapoints.

```{r}


gen_2_clusters_num <- function(cluster_points = c(200, 200), num_vars = 2, num_min_max = 3, seed = 100){
  
  # cluster_points: points per cluster
  # num_vars: how many continuous variables?
  # num_min_max:determines distance between cluster centers; clusters closer if smaller
  
  set.seed(seed)
  
  cl1 <- rmvnorm(cluster_points[1], 
                 mean = runif(num_vars, min = -num_min_max, max = num_min_max), 
                 sigma = rcorrmatrix(num_vars)) 
  cl2 <- rmvnorm(cluster_points[2], 
                 mean = runif(num_vars, min = -num_min_max, max = num_min_max), 
                 sigma = rcorrmatrix(num_vars))
  
  clust_labels <- c(rep(2, cluster_points[1]), rep(4, cluster_points[2]))
  
  z_con <- as.data.frame(rbind(cl1, cl2))
  names(z_con) <- paste0('num', 1:num_vars)
  
  return(list(data = z_con, labels = clust_labels))
  
}


```

Let's look at the clusters

```{r}

z <- gen_2_clusters_num(num_vars = 3, seed = 777)
pairs(~ ., col = z$labels, data = z$data)

```

## Categorical Variables

Two clusters of categorical variables.
Each categorical variable can take on 5 levels drawn from a discrete uniform distribution.
For low overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and five levels 5, 6, 7, 8, 9 in Cluster 2.
For medium overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and has five levels 4, 5, 6, 7, 8 in Cluster 2.
For high overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and has five levels 3, 4, 5, 6, 7 in Cluster 2.

**why not one-hot encode?**

Is it faster to generate the categorical variables by: calling `ceiling(runif(...))` once and then distributing the result to say three categorical variables? or calling `ceiling(runif(...))` three times, once for each categorical variable?

```{r}

# table(ceiling(runif(100000, min = 0, max = 5)))

system.time({
  for (i in 1:3000000){
    x <- ceiling(runif(1200, min = 0, max = 5))
    x1 <- x[1:400]
    x2 <- x[401:800]
    x3 <- x[801:1200]
  }
})

system.time({
  for (i in 1:3000000){
    x1 <- ceiling(runif(400, min = 0, max = 5))
    x2 <- ceiling(runif(400, min = 0, max = 5))
    x3 <- ceiling(runif(400, min = 0, max = 5))
  }
})

```

Calling `ceiling(runif(...))` is faster by ~15%

```{r}

gen_2_clusters_cat <- function(cluster_points = c(200, 200), cat_vars = 2, overlap = "low", seed = 100){
  # cluster_points: points per cluster
  # cat_vars: how many categorical variables?
  # overlap: ('low', 'medium', 'high') determines overlap in categorical variables; Each categorical variable can take on 5 levels drawn from a discrete uniform distribution.For low overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and five levels 5, 6, 7, 8, 9 in Cluster 2. For medium overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and has five levels 4, 5, 6, 7, 8 in Cluster 2. For high overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and has five levels 3, 4, 5, 6, 7 in Cluster 2.
  
  set.seed(seed)
  
  if !(overlap in c("low", 'medium', "high")){
    
  }
  
}

```



```{r}

R.Version()
R.version
version

```



## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
