---
title: "Simulating Clusters with Both Continuous and Categorical Variables"
output: rmarkdown::github_document
date: '2022-08-11'
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo = TRUE,
  fig.retina = 2,
  message = FALSE,
  warning = FALSE
)

```


## Continuous Variables

Convex clusters of continuous variables can be generated simply as multivariate Gaussians.

```{r}

# load packages

library(mvtnorm) # for function rmvnorm
library(clusterGeneration) # for function rcorrmatrix

```

Generate two clusters. 

To generate a Gaussian cluster, we need to specify the cluster mean vector and the cluster covariance matrix. 

The mean vectors are generated by random sampling from a continuous uniform distribution. The distance between the cluster means is a function of the interval length of the uniform distribution: a shorter interval leads to clusters that are closer to each other. 

The `rcorrmatrix` function from the package `clusterGeneration` generates random correlation matrices and is used to generate the covariance matrices for the clusters.

The randomly generated mean vector and covariance matrix are then inputs to the `rmvnorm` function from the `mvtnorm` package which outputs the desired number of cluster datapoints.

```{r}


gen_2_clusters_con <- function(cluster_points = c(200, 200), con_vars = 2, con_dist = 3, seed = 100){
  
  # cluster_points: points per cluster
  # con_vars: how many continuous variables?
  # con_dist: determines distance between cluster centers; clusters closer if smaller
  
  # load required packages

  library(mvtnorm) # for function rmvnorm
  library(clusterGeneration) # for function rcorrmatrix
  
  set.seed(seed)
  
  cl1 <- rmvnorm(cluster_points[1], 
                 mean = runif(con_vars, min = -con_dist, max = con_dist), 
                 sigma = rcorrmatrix(con_vars)) 
  cl2 <- rmvnorm(cluster_points[2], 
                 mean = runif(con_vars, min = -con_dist, max = con_dist), 
                 sigma = rcorrmatrix(con_vars))
  
  clust_labels <- c(rep(2, cluster_points[1]), rep(4, cluster_points[2]))
  
  z_con <- as.data.frame(rbind(cl1, cl2))
  names(z_con) <- paste0('con', 1:con_vars)
  
  return(list(data = z_con, labels = clust_labels))
  
}


```

Let's look at the clusters

```{r}

z <- gen_2_clusters_con(con_vars = 3, seed = 7777)
pairs(~ ., col = z$labels, data = z$data)

```

## Categorical Variables

Two clusters of categorical variables.
Each categorical variable can take on 5 levels drawn from a discrete uniform distribution.
For low overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and five levels 5, 6, 7, 8, 9 in Cluster 2.
For medium overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and has five levels 4, 5, 6, 7, 8 in Cluster 2.
For high overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and has five levels 3, 4, 5, 6, 7 in Cluster 2.

**why not one-hot encode?**

Is it faster to generate the categorical variables by: calling `ceiling(runif(...))` once and then distributing the result to say three categorical variables? or calling `ceiling(runif(...))` three times, once for each categorical variable?

```{r}

# table(ceiling(runif(100000, min = 0, max = 5)))

system.time({
  for (i in 1:3000000){
    x <- ceiling(runif(1200, min = 0, max = 5))
    x1 <- x[1:400]
    x2 <- x[401:800]
    x3 <- x[801:1200]
  }
})

system.time({
  for (i in 1:3000000){
    x1 <- ceiling(runif(400, min = 0, max = 5))
    x2 <- ceiling(runif(400, min = 0, max = 5))
    x3 <- ceiling(runif(400, min = 0, max = 5))
  }
})

```

Calling `ceiling(runif(...))` multiple times is faster by ~15%

```{r}

gen_2_clusters_cat <- function(cluster_points = c(200, 200), cat_vars = 2, overlap = "low", seed = 100){
  # cluster_points: points per cluster
  # cat_vars: how many categorical variables?
  # overlap: ('low', 'medium', 'high') determines overlap in categorical variables; Each categorical variable can take on 5 levels drawn from a discrete uniform distribution.For low overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and five levels 5, 6, 7, 8, 9 in Cluster 2. For medium overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and has five levels 4, 5, 6, 7, 8 in Cluster 2. For high overlap, categorical variable A has five levels 1, 2, 3, 4, 5 in Cluster 1 and has five levels 3, 4, 5, 6, 7 in Cluster 2.
  
  set.seed(seed)
  
  if (!(overlap %in% c("low", "medium", "high"))){
    stop("overlap must be one of 'low', 'medium', 'high'")
  }
  
  M <- matrix(nrow = sum(cluster_points), ncol = cat_vars)
  
  lo <- function(){
    for (i in 1:cat_vars){
      M[, i] <<- c(ceiling(runif(cluster_points[1], min = 0, max = 5)), 
                  ceiling(runif(cluster_points[2], min = 4, max = 9)))
    }
  }
  
  med <- function(){
    for (i in 1:cat_vars){
      M[, i] <<- c(ceiling(runif(cluster_points[1], min = 0, max = 5)), 
                  ceiling(runif(cluster_points[2], min = 3, max = 8)))
    }
  }
  
  hi <- function(){
    for (i in 1:cat_vars){
      M[, i] <<- c(ceiling(runif(cluster_points[1], min = 0, max = 5)), 
                  ceiling(runif(cluster_points[2], min = 2, max = 7)))
    }
  }
  
  switch(overlap,
         low = lo(),
         medium = med(),
         high = hi(), 
         stop("overlap must be one of 'low', 'medium', 'high'"))
  
  clust_labels <- c(rep(2, cluster_points[1]), rep(4, cluster_points[2]))
  
  z_cat <- as.data.frame(M)
  names(z_cat) <- paste0('cat', 1:cat_vars)
  
  return(list(data = z_cat, labels = clust_labels))
}

z <- gen_2_clusters_cat()
pairs(jitter(as.matrix(z$data)), col = z$labels)

```

Let's look at the clusters

```{r plot categorical variables}

z <- gen_2_clusters_cat(overlap = "medium")
pairs(jitter(as.matrix(z$data)), col = z$labels)

z <- gen_2_clusters_cat(overlap = "high")
pairs(jitter(as.matrix(z$data)), col = z$labels)

```

Now generate 2 mixed-data clusters (both continuous and categorical variables)

```{r}

gen_2_clusters_mixed <- function(cluster_points = c(200, 200), con_vars = 2, con_dist = 3, seed = 7777, cat_vars = 2, overlap = "low"){
  # combines the functions gen_2_clusters_con and gen_2_clusters_cat
  
  z_con <- gen_2_clusters_con(cluster_points, con_vars, con_dist, seed)
  z_cat <- gen_2_clusters_cat(cluster_points, cat_vars, overlap, seed)
  
  return(list(data = cbind(z_con$data, z_cat$data), labels = z_con$labels))
}

z <- gen_2_clusters_mixed()
str(z)

pairs(~ ., col = z$labels, data = z$data)

```

Session info

```{r}

R.Version()
R.version
version
sessionInfo()

```

